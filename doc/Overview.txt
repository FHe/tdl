
This is tdl (Tom's Data Language, or maybe Tiny Data Language).

Tdl is a data processing language written in python and designed to be 
  - easy to use for novices.
  - complete enough for intermediate to advanced data processing.
  - data-centric, so that arrays of data are easy to manage and use.
  - easily extensible with python.
 
Tdl uses numpy (version 0.9.6 or higher) for all its numerical
functionality, so processing arrays of data is easy.  Tdl will also soon
require scipy, as this will allow 'advanced numeric capabilities',
including non-linear least squares minimization and ffts.

Features:
 - simple undecorated variable names that can contain any of the following
   data types: ints, floats, complex, strings, lists, dictionaries
   (hashes), or numpy arrays. Multi-dimensional data can be accessed
   either element-by-element or with slices:

      tdl> x   = 1             # int
      tdl> y   = 7 + 2j        # complex number:  real + imag'j'
      tdl> arr = arange(10)    # simple array 
      tdl> print arr 
      [0 1 2 3 4 5 6 7 8 9 10]
      tdl> print arr[3]
      3
      tdl> print arr[2:8]
      [2 3 4 5 6 7]

      tdl> str = 'here is a string'
      tdl> print str[0:6]
      here i

   the underlying data types are all Python (or numpy) types.

 - Namespaces.  Each variable has two parts to its name: a Group Name and 
   Variable Name.  The fully qualified name includes a '.': Group.Var.
   Unqualified names (ie, a name without a 'group.' prefix) will become
   part of the default group.  At startup, the default group is '_main',
   but can be changed using "setgroup(groupname)":
     tdl> x = 1
     tdl> group1.x = 3.3
     tdl> print x
     1
     tdl> setgroup('group1')
     tdl> print x
     3.3
     tdl> print _main.x, group1.x
     1 3.3
  
   In addition to _main, there are two other groups at startup: _builtin,
   which holds constants and program state information such as the name of
   the default group.  This _builtin group is special in that it cannot be
   easily altered from tdl directly. There is also a group called _function
   which is used to hold all the functions and user-defined procedures.

   You can also assign variables variable values with setvar():
     tdl> setvar('v', 2.3, group='group1')
     tdl> print group1.v

   The potential advantage here is that 'v' and 'group1' are string types,
   not literal variable names, so they can be computed or passed in a
   procedure. 


 - complete and clean syntax for programming:
    The syntax is python-like, with some exceptions.  Most importantly, 
    indentation doesn't matter, and blocks end with 'end' statements.
    A typical for-block will look like this:
       for i in range(10):
           print i
       endfor     

    there are also while blocks and if-elif-else blocks:
       n = 0
       while n<10: 
          print ' n = ',n
          if n==3: print 'here is 3!!'
          n = n + 1
       endwhile
     
       if n > 10:
          print 'No'
       elif n > 5 and n < 8:
          print 'Maybe'
       else:
          print 'Yep'
       endif

    A design goal is that well-formed tdl code should be very easy to
    translate into valid python (and vice versa).

 - user-defined functions (aka procedures):
    User defined functions can be written in tdl:
        def  myfunc(arg1, option='test'):
            'documentation string'
            print 'this is my funcition ', arg1
            print 'optional param = ', option
            if type(option) != 'string':     
                 print 'option must be a string!!'
                return False
            endif
            value = sqrt(arg1)
            x.tmp = value
            return value > 10.
        enddef

     which could be called as 
        tdl> ret = myfunc(3., option = 'xx')
        tdl> print ret, x.tmp
        False 1.73205080757

 - load() function:
    you can run a file of tdl commands with the load() function:
       tdl> load('myfile.tdl')

 - eval() function:
    you can construct a tdl expression on the fly from strings and execute
    it:

       tdl> eval("%s.value = %f" %  ('group', 10.2))
       tdl> print group.value 
       10.2

 - read_ascii() function:
    you can read in ASCII column data files very easily.
      tdl> read_ascii('my.dat', group='f')
      ['f', 'x', ''y']
      
     this read 2 columns (labeled 'x' and 'y') from the column file and
     created the array variables f.x and f.y.  Also created was 
       f.titles
     to hold the titles in the data file (non-numeric content at the top of
     the file) and 
       f.column_labels

 - on-line help:
    still in progress.

 - easy to add your python functions, including getting access to all  
   the 'data groups' inside your python function.

    ....
   see tdl_read_ascii in tdl/TdlLib.py

=== Differences between tdl and Python:

-  tdl has many builtins and assumes numerical data (that is, arrays of numbers).
-  tdl has no tuples. Lists are used in their place.
-  indentation does not matter. blocks are ended with 'end***' 
   (if / endif , fo/endfor, def/enddef)

-  when in doubt, assignment makes a copy, and does not give a reference
-  data types are not generally objects, and have no methods associated
   with them.  Tdl use procedural approaches:
     x = arange(100)
     reshape(x,[10,10])   instead of x.shape = (10,10)

