
==Using numpy 0.9.6
   numpy 0.9.6 is now required. This is sort of big step, but it definitely
   helps with multi-dimensional code.

==Fixed array slicing.
 The following slicings work (compatible with numpy):
   1-D arrays:
      x[1]     x[:3]     x[2:]    x[2:10]    x[2:10:2] 

   2-D / Multi-D arrays
      x[1,2]  == x[1][2]
      x[1:3,4:5]
      x[:4:2,0:20:4]  
   and so on.
 
   Note that x[:5][2] == x[:5,2], which may be different from (x[:5][2])
 
     x = arange(100,shape=[10,10])
     print x[:5]
        [[  0.   1.   2.   3.   4.   5.   6.   7.   8.   9.]
         [ 10.  11.  12.  13.  14.  15.  16.  17.  18.  19.]
         [ 20.  21.  22.  23.  24.  25.  26.  27.  28.  29.]
         [ 30.  31.  32.  33.  34.  35.  36.  37.  38.  39.]
         [ 40.  41.  42.  43.  44.  45.  46.  47.  48.  49.]]

     print x[:5][2]
        [  2.  12.  22.  32.  42.]

     print x[:5,2]
        [  2.  12.  22.  32.  42.]

     print (x[:5])[2]
        [ 20.  21.  22.  23.  24.  25.  26.  27.  28.  29.]

==multi-line strings sort of work, but have a bug that newlines are lost in
  interactive mode.... I haven't looked into this very far.

==file i/o:
  added open, close, write, read, readlines functions to _builtin so that 
     f = open('file.dat','r')
     l = readlines(f)
     close(f)
 
  and
     f = open('file.dat','w')
     write(f, 'a string\n')
     close(f)
  work.  These are fairly thin wrappers of the python functionality.


==Added 'del' keyword
   
   tdl>  del x

   now deletes the variable x.  The delvar function is no longer used.

== Added try /except /endtry  construct:
    
   I have 
       try: 
          <block>
       except:
         <block>
       endtry
   working.  There is not yet any exception information, but I think it
   will be easy to add information from sys.exc_info etc to _main.error_msg
   and _main.error_type and so on, so that some decisions can be made on 
   the type of exception seen.


==Eliminated distinction between 'tdl_func' and 'func'
    If a python function has a tdl= keyword argument, this *will* be used to
  pass in a reference to the tdl session.   There's no need to tag
  'tdl-enabled' functions at import.

==Rearranged code (several changes):
   1. moved importing of libraries into SymbolTable.

   2. re-arranged files Expr.py and Evaluator.py into files Eval.py and  
      Expression.py class.  Eval.py contains one class Evaluator,
      and Expression.py contains opcodes, ExpressionParser, and Expression 
      classes.  

      The ExpressionParser class has been modified slightly, 
      though the expression stack it generates is quite different.
      But this is implementation detail, and the Expression class is the
      preferred way to compile/evaluate an expression:
            >>> e = Expression()
            >>> x = e.compile('2 / 5')
            >>> print x
            ['/', 5.0, 2.0]
            >>> e.eval(x)
            0.4
      or just:
            >>> e.eval('3 / 5')
            0.6

      The Evaluator class encapsulates the TDL language proper, and uses
      Expression for compilation / evaluation of expressions, and keeps a 
      symbolTable for data (and functions -- all named objects).  Evaluator
      has some major modifications, but is largely the same as before.

   3. Set 'ascmd'  to True by default, so that all functions can be
      commands.  Improved allowed syntax of 'commands' so that commas
      are optional and key=val pairs work well. I could be persuaded
      otherwise, but I couldn't think of a reason where a command version
      of any function should not be allowed.  If all functions can be
      commands, it seems that the ascmd options could be eliminated.
     

   4.  moved Lib -> TdlLib -> TdlBuiltins.py


==Returned Shell to using Cmd.cmd:
    Works way better on *nix, just as well on Win32 (for me, anyway, as the
    up arrow works). I think I have most of your shell stuff implemented.

==Altered Help system:
    There is now a Help class that stores a dictionary of topics/text
    pairs.  An imported library can now include a '_help_' dictionary 
    that will fill in the topics with actual help content..

    This dramatically changed 'help ' options in Shell.  I think it's
    similar in spirit to TT's and can be altered easily enough.  One
    important point is that the Help class will allow a GUI to get the help
    text more easily.

    In addtion to '_func_' and '_consts_' dicts ('_tdl_func_' is no longer
    needed), a  module can also include a '_help_' dict of 'topic name'
    and text.   On importing the module, the topic will automatically
    show up in the list of help topics with 'help topics', and 
    'help <topic name>' will show that help.

    This allows the different modules to easily add their own help.  See
    TdlBuiltin for an (incomplete) example.

    Typing 'help', 'help topics', and 'help show' gives the basic
    introduction to help.

